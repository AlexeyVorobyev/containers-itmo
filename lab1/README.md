# Dockerfile.good vs Dockerfile.bad — кратко про практики

В репозитории два Dockerfile’а:

- `./app/Dockerfile.good` — пример хороших практик: воспроизводимость, меньше образ, безопаснее рантайм.
- `./app/Dockerfile.bad` — пример типичных ошибок: хуже кэш, больше размер, меньше предсказуемость и безопасность.

---

## Что хорошего в Dockerfile.good

- **Multi-stage build (`builder` `final`)**: в финальный образ попадает только нужное для запуска (код + `.venv`).  
  меньше размер, меньше уязвимостей, чище рантайм.

- **Воспроизводимость зависимостей (`uv sync --locked`)**: установка строго по `uv.lock`.  
  одинаковые зависимости в CI/проде/локально.

- **Хороший кэш слоёв**: сначала копируются `pyproject.toml` и `uv.lock`, потом код.  
  изменения кода не заставляют заново ставить зависимости.

- **Минимальные пакеты ОС (`--no-install-recommends`)**: ставится только необходимое.  

- **Зафиксированная версия установщика uv** (`.../uv/0.9.15/...`)  
  сборка не “ломается внезапно” из‑за изменения скрипта.

- **Запуск не от root** (`appuser`) + корректные права (`--chown`)  
  принцип наименьших привилегий, меньше проблем с правами.

- **HEALTHCHECK**  
  оркестратор понимает, жив ли сервис, может перезапустить при зависании.

- **VOLUME для состояния (`/app/resources`)**  
  данные отделены от образа, контейнер можно пересоздавать без потерь.

---

## Что плохого в Dockerfile.bad

- **Тяжелый и непредсказуемый базовый образ** (`FROM python:latest`)
  непредсказуемое поведение и увеличение размера образа.

- **Несколько `RUN` вместо одного** и нет чистки apt-кэша  
  больше слоёв, больше образ, медленнее сборка/пулл.

- **`ADD` установщика uv без фиксации версии** (`.../uv/install.sh`)  
 скрипт может измениться, сборка станет непредсказуемой (supply-chain риск выше).

- **`COPY . .` слишком рано**  
  кэш зависимостей ломается при любом изменении в репо; можно случайно утащить лишние файлы/секреты.

- **Нет `WORKDIR`**  
  пути и окружение менее предсказуемы/читабельны.

- **Запуск от root (по умолчанию)**  
  выше риски безопасности и проблемы с правами на томах.

- **Нет healthcheck/volume/явных прав на директории**  
  сложнее эксплуатация, выше риск потери данных и ошибок доступа.

---

## 2 плохие практики контейнеризации

- **Хранить состояние внутри контейнера без томов/внешнего хранилища**  
  Контейнер одноразовый: пересоздание = потеря данных.  
  Лучше: выносить данные в `VOLUME`, bind-mount или внешние сервисы (DB/S3/Redis).

- **Запускать контейнер с лишними привилегиями** (например `--privileged` или монтировать `/var/run/docker.sock`)  
  Это может дать контейнеру фактически доступ к хосту.  
  Лучше: минимальные права/capabilities, без docker.sock (или только через строго ограниченный прокси).
